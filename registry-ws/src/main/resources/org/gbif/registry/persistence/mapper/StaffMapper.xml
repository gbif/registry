<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="org.gbif.registry.persistence.mapper.StaffMapper">

  <!-- Auto-mapping and eager loading of sub resources  -->
  <resultMap id="STAFF_MAP" type="Staff" autoMapping="true">
    <id property="key" column="key"/>
    <association property="mailingAddress" column="mailing_address_key" select="listAddress" />
    <!-- TODO: subqueries -->
  </resultMap>

  <sql id="STAFF_WRITE_FIELDS">
    key, first_name, last_name, position, area_responsibility, research_pursuits, phone, fax, email,
    mailing_address_key, primary_institution_key, primary_collection_key, created_by, modified_by,
    created, modified
  </sql>

  <sql id="STAFF_READ_FIELDS">
    s.key, s.first_name, s.last_name, s.position, s.area_responsibility, s.research_pursuits, s.phone, s.fax, s.email,
    s.mailing_address_key, s.primary_institution_key, s.primary_collection_key, s.created_by, s.modified_by,
    s.created, s.modified
  </sql>

  <sql id="STAFF_PARAMS_CREATE">
    #{key,jdbcType=OTHER},
    #{firstName,jdbcType=VARCHAR},
    #{lastName,jdbcType=VARCHAR},
    #{position,jdbcType=VARCHAR},
    #{areaResponsibility,jdbcType=VARCHAR},
    #{researchPursuits,jdbcType=VARCHAR},
    #{phone,jdbcType=VARCHAR},
    #{fax,jdbcType=VARCHAR},
    #{email,jdbcType=VARCHAR},
    #{mailingAddress.key,jdbcType=INTEGER},
    #{institutionKey,jdbcType=OTHER},
    #{collectionKey,jdbcType=OTHER},
    #{createdBy,jdbcType=VARCHAR},
    #{modifiedBy,jdbcType=VARCHAR},
    now(), <!-- created -->
    now() <!-- modified -->
  </sql>

  <sql id="STAFF_PARAMS_UPDATE">
    key = #{key,jdbcType=OTHER},
    first_name = #{firstName,jdbcType=VARCHAR},
    last_name = #{lastName,jdbcType=VARCHAR},
    position = #{position,jdbcType=VARCHAR},
    area_responsibility = #{areaResponsibility,jdbcType=VARCHAR},
    research_pursuits = #{researchPursuits,jdbcType=VARCHAR},
    phone = #{phone,jdbcType=VARCHAR},
    fax = #{fax,jdbcType=VARCHAR},
    email = #{email,jdbcType=VARCHAR},
    mailing_address_key = #{mailingAddress.key,jdbcType=INTEGER},
    primary_institution_key = #{institutionKey,jdbcType=OTHER},
    primary_collection_key = #{collectionKey,jdbcType=OTHER},
    created_by = #{createdBy,jdbcType=VARCHAR},
    modified_by = #{modifiedBy,jdbcType=VARCHAR},
    created = now(), <!-- created -->
    modified = now() <!-- modified -->
  </sql>

  <sql id="SIMPLE_SEARCH">
    query @@ fulltext_search
    OR EXISTS(
    SELECT key
    FROM address maddr
    WHERE maddr.key=s.mailing_address_key AND query @@ maddr.fulltext_search
    )
  </sql>

  <insert id="create" parameterType="Staff">
    INSERT INTO collection_staff(<include refid="STAFF_WRITE_FIELDS"/>)
    VALUES(<include refid="STAFF_PARAMS_CREATE"/>)
  </insert>

  <update id="update" parameterType="Staff">
    UPDATE collection_staff
    SET <include refid="STAFF_PARAMS_UPDATE"/>
    WHERE key = #{key,jdbcType=OTHER}
  </update>

  <!-- For safety, should it be already deleted nothing is done -->
  <update id="delete">
    UPDATE collection_staff
    SET deleted = now()
    WHERE key = #{key,jdbcType=OTHER} AND deleted IS NULL
  </update>

  <!--  Note: you can get entities which are deleted -->
  <select id="get" resultMap="STAFF_MAP">
    SELECT <include refid="STAFF_READ_FIELDS"/>
    FROM collection_staff s
    WHERE s.key = #{key,jdbcType=OTHER}
  </select>

  <select id="listAddress" resultMap="org.gbif.registry.persistence.mapper.AddressMapper.ADDRESS_MAP">
    SELECT <include refid="org.gbif.registry.persistence.mapper.AddressMapper.ADDRESS_READ_FIELDS"/>
    FROM address
    WHERE key = #{key,jdbcType=OTHER}
  </select>

  <select id="list" resultType="Staff"  resultMap="STAFF_MAP" parameterType="Pageable">
    SELECT <include refid="STAFF_READ_FIELDS"/>
    FROM collection_staff s
    WHERE s.deleted IS NULL
    ORDER BY s.created DESC, s.key
    <if test="page != null" >
      LIMIT #{page.limit} OFFSET #{page.offset}
    </if>
  </select>

  <!-- Basic paging search functionality -->
  <select id="search" resultMap="STAFF_MAP">
    SELECT <include refid="STAFF_READ_FIELDS"/>
    FROM collection_staff s
    <if test="query != null" >
      JOIN plainto_tsquery('english',unaccent(#{query})) AS query ON  <include refid="SIMPLE_SEARCH"/>
    </if>
    WHERE s.deleted IS NULL
    ORDER BY <if test="query != null" >ts_rank_cd(s.fulltext_search, query) DESC, </if>s.created DESC, s.key
    <if test="page != null" >
      LIMIT #{page.limit} OFFSET #{page.offset}
    </if>
  </select>

  <select id="listStaffByInstitution" resultMap="STAFF_MAP" parameterType="Pageable">
    SELECT <include refid="STAFF_READ_FIELDS"/>
    FROM collection_staff s
    WHERE s.primary_institution_key = #{institutionKey,jdbcType=OTHER}
    AND s.deleted IS NULL
    ORDER BY s.created DESC, s.key
    <if test="page != null" >
      LIMIT #{page.limit} OFFSET #{page.offset}
    </if>
  </select>

  <select id="listStaffByCollection" resultMap="STAFF_MAP" parameterType="Pageable">
    SELECT <include refid="STAFF_READ_FIELDS"/>
    FROM collection_staff s
    WHERE s.primary_collection_key = #{collectionKey,jdbcType=OTHER}
    AND s.deleted IS NULL
    ORDER BY s.created DESC, s.key
    <if test="page != null" >
      LIMIT #{page.limit} OFFSET #{page.offset}
    </if>
  </select>

</mapper>
