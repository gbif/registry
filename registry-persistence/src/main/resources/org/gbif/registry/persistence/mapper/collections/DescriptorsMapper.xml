<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="org.gbif.registry.persistence.mapper.collections.DescriptorsMapper">

    <resultMap id="DESCRIPTOR_MAP" type="Descriptor" autoMapping="true">
        <id property="key" column="key"/>
    </resultMap>

    <sql id="DESCRIPTOR_WRITE_FIELDS">
        title, description, collection_key, created, created_by, modified, modified_by
    </sql>

    <sql id="DESCRIPTOR_READ_FIELDS">
        d.key, d.title, d.description, d.collection_key, d.created, d.created_by, d.modified, d.modified_by, d.deleted
    </sql>

    <sql id="DESCRIPTOR_PARAMS_CREATE">
        #{title,jdbcType=VARCHAR},
        #{description,jdbcType=VARCHAR},
        #{collectionKey,jdbcType=OTHER},
        now(), <!-- created -->
        #{createdBy,jdbcType=VARCHAR},
        now(), <!-- modified -->
        #{modifiedBy,jdbcType=VARCHAR}
    </sql>

    <sql id="DESCRIPTOR_PARAMS_UPDATE">
        title = #{title,jdbcType=VARCHAR},
        description = #{description,jdbcType=VARCHAR},
        modified_by = #{modifiedBy,jdbcType=VARCHAR},
        modified = now(), <!-- modified -->
        deleted = null <!-- if we're updating it can't be deleted -->
        <!-- disallowed to update the collection key -->
    </sql>

    <sql id="FULLTEXT_SEARCH">
        JOIN to_tsquery('english',regexp_replace(quote_literal(unaccent(trim(#{params.query}))),'\s+',':*&amp;','g')||':*')
        AS query ON query @@ fulltext_search
    </sql>

    <insert id="createDescriptor" parameterType="Descriptor" useGeneratedKeys="true" keyProperty="key">
        INSERT INTO collection_descriptor(<include refid="DESCRIPTOR_WRITE_FIELDS"/>)
        VALUES(<include refid="DESCRIPTOR_PARAMS_CREATE"/>)
    </insert>

    <update id="updateDescriptor" parameterType="Descriptor">
        UPDATE collection_descriptor
        SET
        <include refid="DESCRIPTOR_PARAMS_UPDATE"/>
        WHERE key = #{key,jdbcType=OTHER}
    </update>

    <update id="deleteDescriptor">
        UPDATE collection_descriptor
        SET deleted = now()
        WHERE key = #{key,jdbcType=OTHER} AND deleted IS NULL
    </update>

    <select id="getDescriptor" resultMap="DESCRIPTOR_MAP">
        SELECT
        <include refid="DESCRIPTOR_READ_FIELDS"/>
        FROM collection_descriptor d
        WHERE d.key = #{key,jdbcType=OTHER}
    </select>

    <select id="listDescriptors" resultType="Descriptor" resultMap="DESCRIPTOR_MAP" parameterType="Pageable">
        SELECT DISTINCT ON(
        <if test="params.query != null">ts_rank_cd(d.fulltext_search, query),</if>
        d.created, d.key)
        <include refid="DESCRIPTOR_READ_FIELDS"/>, d.fulltext_search
        <include refid="LIST_DESCRIPTORS_FILTER"/>
        ORDER BY <if test="params.query != null">ts_rank_cd(d.fulltext_search, query) DESC,</if>d.created DESC, d.key
        <if test="params.page != null">
            LIMIT #{params.page.limit} OFFSET #{params.page.offset}
        </if>
    </select>

    <select id="countDescriptors" resultType="Long">
        SELECT COUNT(DISTINCT d.key)
        <include refid="LIST_DESCRIPTORS_FILTER"/>
    </select>

    <sql id="LIST_DESCRIPTORS_FILTER">
        FROM collection_descriptor d
        <if test="params.query != null">
            <include refid="FULLTEXT_SEARCH"/>
        </if>
        <where>
            <if test="params.collectionKey != null">
                d.collection_key = #{params.collectionKey,jdbcType=OTHER}
            </if>
            <if test="params.title != null">
                AND lower(d.title) = lower(#{params.title,jdbcType=VARCHAR})
            </if>
            <if test="params.description != null">
                AND lower(d.description) = lower(#{params.description,jdbcType=VARCHAR})
            </if>
        </where>
    </sql>

    <!-- record queries -->
    <resultMap id="RECORD_DTO_MAP" type="DescriptorRecordDto" autoMapping="true">
        <id property="key" column="key"/>
        <result property="descriptorKey" column="collection_descriptor_key"/>
        <result property="identifiedBy" column="identified_by" typeHandler="StringArrayTypeHandler"/>
        <result property="typeStatus" column="type_status" typeHandler="StringArrayTypeHandler"/>
        <result property="recordedBy" column="recorded_by" typeHandler="StringArrayTypeHandler"/>
        <result property="issues" column="issues" typeHandler="StringArrayTypeHandler"/>
        <collection property="verbatim" column="key" select="listVerbatims"/>
    </resultMap>

    <sql id="RECORD_WRITE_FIELDS">
        collection_descriptor_key, scientific_name, country, individual_count, identified_by, date_identified,
        type_status,
        recorded_by, discipline, object_classification_name, issues
    </sql>

    <sql id="RECORD_READ_FIELDS">
        r.key, r.collection_descriptor_key, r.scientific_name, r.country, r.individual_count, r.identified_by,
        r.date_identified, r.type_status, r.recorded_by, r.discipline, r.object_classification_name, r.issues
    </sql>

    <sql id="RECORD_PARAMS_CREATE">
        #{descriptorKey,jdbcType=INTEGER},
        #{scientificName,jdbcType=VARCHAR},
        #{country,jdbcType=VARCHAR},
        #{individualCount,jdbcType=INTEGER},
        #{identifiedBy,jdbcType=ARRAY,typeHandler=StringArrayTypeHandler},
        #{dateIdentified,jdbcType=OTHER},
        #{typeStatus,jdbcType=ARRAY,typeHandler=StringArrayTypeHandler},
        #{recordedBy,jdbcType=ARRAY,typeHandler=StringArrayTypeHandler},
        #{discipline,jdbcType=VARCHAR},
        #{objectClassification,jdbcType=VARCHAR},
        #{issues,jdbcType=ARRAY,typeHandler=StringArrayTypeHandler}
    </sql>

    <insert id="createRecord" parameterType="DescriptorRecord" useGeneratedKeys="true" keyProperty="key">
        INSERT INTO collection_descriptor_record(<include refid="RECORD_WRITE_FIELDS"/>)
        VALUES(<include refid="RECORD_PARAMS_CREATE"/>)
    </insert>

    <delete id="deleteRecords">
        DELETE FROM collection_descriptor_record
        WHERE collection_descriptor_key = #{descriptorKey,jdbcType=INTEGER}
    </delete>

    <select id="getRecord" resultMap="RECORD_DTO_MAP">
        SELECT
        <include refid="RECORD_READ_FIELDS"/>
        FROM collection_descriptor_record r
        WHERE r.key = #{key,jdbcType=OTHER}
    </select>

    <select id="listRecords" resultType="DescriptorRecord" resultMap="RECORD_DTO_MAP" parameterType="Pageable">
        SELECT DISTINCT ON(
        <if test="params.query != null">ts_rank_cd(d.fulltext_search, query),</if>
        r.key)
        <include refid="RECORD_READ_FIELDS"/>, r.fulltext_search
        <include refid="LIST_RECORDS_FILTER"/>
        ORDER BY <if test="params.query != null">ts_rank_cd(r.fulltext_search, query) DESC,</if> r.key
        <if test="params.page != null">
            LIMIT #{params.page.limit} OFFSET #{params.page.offset}
        </if>
    </select>

    <select id="countRecords" resultType="Long">
        SELECT COUNT(DISTINCT r.key)
        <include refid="LIST_RECORDS_FILTER"/>
    </select>

    <sql id="LIST_RECORDS_FILTER">
        FROM collection_descriptor_record r
        <if test="params.query != null">
            <include refid="FULLTEXT_SEARCH"/>
        </if>
        <where>
            <if test="params.descriptorKey != null">
                AND r.collection_descriptor_key = #{params.descriptorKey,jdbcType=OTHER}
            </if>
            <if test="params.scientificName != null and params.scientificName.size > 0">
                AND r.scientific_name IN
                <foreach item="item" collection="params.scientificName" open="(" separator="," close=")">
                    #{item,jdbcType=VARCHAR}
                </foreach>
            </if>
            <if test="params.country != null  and params.country.size > 0">
                AND r.country IN
                <foreach item="item" collection="params.country" open="(" separator="," close=")">
                    #{item,jdbcType=VARCHAR}
                </foreach>
            </if>
            <if test="params.individualCount != null">
                <choose>
                    <when test="params.individualCount.exactValue != null">
                        AND r.individual_count = #{params.individualCount.exactValue,jdbcType=INTEGER}
                    </when>
                    <otherwise>
                        <if test="params.individualCount.lowerBound != null">
                            AND r.individual_count >= #{params.individualCount.lowerBound,jdbcType=INTEGER}
                        </if>
                        <if test="params.individualCount.higherBound != null">
                            AND r.individual_count &lt;= #{params.individualCount.higherBound,jdbcType=INTEGER}
                        </if>
                    </otherwise>
                </choose>
            </if>
            <if test="params.identifiedBy != null and params.identifiedBy.size > 0">
                AND r.identified_by &amp;&amp; ARRAY
                <foreach item="item" collection="params.identifiedBy" open="[" separator="," close="]">
                    #{item,jdbcType=VARCHAR}::text
                </foreach>
            </if>
            <if test="params.dateIdentified != null">
                AND r.individual_count = #{params.individualCount,jdbcType=VARCHAR}
            </if>
            <if test="params.dateIdentifiedFrom != null">AND r.date_identified &gt;= #{params.dateIdentifiedFrom}</if>
            <if test="params.dateIdentifiedBefore != null">AND r.date_identified &lt; #{params.dateIdentifiedBefore}
            </if>
            <if test="params.typeStatus != null and params.typeStatus.size > 0">
                AND r.type_status &amp;&amp; ARRAY
                <foreach item="item" collection="params.typeStatus" open="[" separator="," close="]">
                    #{item,jdbcType=VARCHAR}::text
                </foreach>
            </if>
            <if test="params.recordedBy != null and params.recordedBy.size > 0">
                AND r.recorded_by &amp;&amp; ARRAY
                <foreach item="item" collection="params.recordedBy" open="[" separator="," close="]">
                    #{item,jdbcType=VARCHAR}::text
                </foreach>
            </if>
            <if test="params.discipline != null  and params.discipline.size > 0">
                AND r.discipline IN
                <foreach item="item" collection="params.discipline" open="(" separator="," close=")">
                    #{item,jdbcType=VARCHAR}
                </foreach>
            </if>
            <if test="params.objectClassification != null  and params.objectClassification.size > 0">
                AND r.object_classification_name IN
                <foreach item="item" collection="params.objectClassification" open="(" separator="," close=")">
                    #{item,jdbcType=VARCHAR}
                </foreach>
            </if>
            <if test="params.issues != null and params.issues.size > 0">
                AND r.issues &amp;&amp; ARRAY
                <foreach item="item" collection="params.issues" open="[" separator="," close="]">
                    #{item,jdbcType=VARCHAR}::text
                </foreach>
            </if>
        </where>
    </sql>

    <!-- verbatim fields queries -->
    <resultMap id="VERBATIM_DTO_MAP" type="VerbatimDto" autoMapping="true">
        <id property="key" column="key"/>
    </resultMap>

    <sql id="VERBATIM_WRITE_FIELDS">
        collection_descriptor_record_key, field_name, field_value
    </sql>

    <sql id="VERBATIM_READ_FIELDS">
        v.key, v.collection_descriptor_record_key, v.field_name, v.field_value
    </sql>

    <sql id="VERBATIM_PARAMS_CREATE">
        #{recordKey,jdbcType=INTEGER},
        #{fieldName,jdbcType=VARCHAR},
        #{fieldValue,jdbcType=VARCHAR}
    </sql>

    <insert id="createVerbatim" useGeneratedKeys="true" keyProperty="key">
        INSERT INTO collection_descriptor_verbatim_field(<include refid="VERBATIM_WRITE_FIELDS"/>)
        VALUES(<include refid="VERBATIM_PARAMS_CREATE"/>)
    </insert>

    <delete id="deleteVerbatim">
        DELETE FROM collection_descriptor_verbatim_field
        WHERE collection_descriptor_record_key = #{recordKey,jdbcType=INTEGER}
    </delete>

    <!-- TODO: try cascade -->
    <delete id="deleteVerbatimFromDescriptor">
        DELETE FROM collection_descriptor_verbatim_field v
        INNER JOIN collection_descriptor_record r ON r.key = v.collection_descriptor_record_key
        INNER JOIN collection_descriptor d ON d.key = r.collection_descriptor_key
        WHERE d.key = #{descriptorKey,jdbcType=INTEGER}
    </delete>

    <select id="listVerbatims" resultType="VerbatimDto" resultMap="VERBATIM_DTO_MAP">
        SELECT
        <include refid="VERBATIM_READ_FIELDS"/>
        FROM collection_descriptor_verbatim_field v
        WHERE v.collection_descriptor_record_key = #{recordKey,jdbcType=INTEGER}
    </select>

</mapper>
