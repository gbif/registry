<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="org.gbif.registry.persistence.mapper.DownloadStatisticsMapper">

  <resultMap id="DOWNLOADS_STATISTICS_COUNT_MAP" type="org.gbif.api.model.common.search.Facet$Count" autoMapping="true">
    <result property="name" column="year_month" />
    <result property="count" column="number_downloads" />
  </resultMap>

  <resultMap id="DOWNLOADS_STATISTICS_TOTAL_RECORDS_MAP" type="org.gbif.api.model.common.search.Facet$Count" autoMapping="true">
    <result property="name" column="year_month" />
    <result property="count" column="total_records" />
  </resultMap>

  <resultMap id="DOWNLOAD_STATISTICS" type="org.gbif.api.model.occurrence.DownloadStatistics" autoMapping="true"/>

  <select id="getDownloadsByUserCountry" resultType="org.gbif.api.model.common.search.Facet$Count" resultMap="DOWNLOADS_STATISTICS_COUNT_MAP" parameterType="map">
    SELECT to_char(year_month AT TIME ZONE 'UTC','YYYY-MM') AS year_month, SUM(number_downloads) AS number_downloads
    FROM download_user_statistics
    <where>
      <if test="userCountry != null">AND user_country = #{userCountry,jdbcType=OTHER}</if>
      <if test="type != null">AND type = #{type,jdbcType=OTHER}</if>
      <if test="fromDate != null" ><![CDATA[AND year_month >= #{fromDate,jdbcType=TIMESTAMP}]]></if>
      <if test="toDate != null" ><![CDATA[AND year_month < #{toDate,jdbcType=TIMESTAMP}]]></if>
    </where>
    GROUP BY year_month
    ORDER BY year_month DESC;
  </select>

  <select id="getDownloadsBySource" resultType="org.gbif.api.model.common.search.Facet$Count" resultMap="DOWNLOADS_STATISTICS_COUNT_MAP" parameterType="map">
    SELECT to_char(year_month AT TIME ZONE 'UTC','YYYY-MM') AS year_month, SUM(number_downloads) AS number_downloads
    FROM download_source_statistics
    <where>
      <if test="source != null">AND source = #{source,jdbcType=OTHER}</if>
      <if test="type != null">AND type = #{type,jdbcType=OTHER}</if>
      <if test="fromDate != null" ><![CDATA[AND year_month >= #{fromDate,jdbcType=TIMESTAMP}]]></if>
      <if test="toDate != null" ><![CDATA[AND year_month < #{toDate,jdbcType=TIMESTAMP}]]></if>
    </where>
    GROUP BY year_month
    ORDER BY year_month DESC;
  </select>

  <select id="getDownloadedRecordsByDataset" resultType="org.gbif.api.model.common.search.Facet$Count" resultMap="DOWNLOADS_STATISTICS_TOTAL_RECORDS_MAP" parameterType="map">
    SELECT to_char(ds.year_month AT TIME ZONE 'UTC','YYYY-MM') AS year_month, SUM(ds.total_records) AS total_records
    FROM download_statistics ds
    <if test="publishingOrgKey != null">
    JOIN dataset d ON d.key = ds.dataset_key AND d.publishing_organization_key = #{publishingOrgKey,jdbcType=OTHER}
    </if>
    <where>
      <if test="publishingCountry != null">AND ds.publishing_organization_country = #{publishingCountry,jdbcType=OTHER}</if>
      <if test="datasetKey != null">AND ds.dataset_key = #{datasetKey,jdbcType=OTHER}</if>
      <if test="type != null">AND ds.type = #{type,jdbcType=OTHER}</if>
      <if test="fromDate != null"><![CDATA[AND ds.year_month >= #{fromDate,jdbcType=TIMESTAMP}]]></if>
      <if test="toDate != null"><![CDATA[AND ds.year_month < #{toDate,jdbcType=TIMESTAMP}]]></if>
    </where>
    GROUP BY ds.year_month
    ORDER BY ds.year_month DESC;
  </select>

  <select id="getDownloadsByDataset" resultType="org.gbif.api.model.common.search.Facet$Count" resultMap="DOWNLOADS_STATISTICS_COUNT_MAP" parameterType="map">
    SELECT to_char(ds.year_month AT TIME ZONE 'UTC','YYYY-MM') AS year_month, SUM(ds.number_downloads) AS number_downloads
    FROM download_statistics ds
    <if test="publishingOrgKey != null">
    JOIN dataset d ON d.key = ds.dataset_key AND d.publishing_organization_key = #{publishingOrgKey,jdbcType=OTHER}
    </if>
    <where>
      <if test="publishingCountry != null">AND ds.publishing_organization_country = #{publishingCountry,jdbcType=OTHER}</if>
      <if test="datasetKey != null">AND ds.dataset_key = #{datasetKey,jdbcType=OTHER}</if>
      <if test="type != null">AND ds.type = #{type,jdbcType=OTHER}</if>
      <if test="fromDate != null"><![CDATA[AND ds.year_month >= #{fromDate,jdbcType=TIMESTAMP}]]></if>
      <if test="toDate != null"><![CDATA[AND ds.year_month < #{toDate,jdbcType=TIMESTAMP}]]></if>
    </where>
    GROUP BY ds.year_month
    ORDER BY ds.year_month DESC;
  </select>

  <select id="getDownloadStatistics" resultMap="DOWNLOAD_STATISTICS" parameterType="map">
    SELECT ds.year_month, ds.dataset_key, SUM(ds.number_downloads) AS number_downloads, SUM(ds.total_records) AS total_records
    FROM download_statistics ds
    <if test="publishingOrgKey != null">
      JOIN dataset d ON d.key = ds.dataset_key AND d.publishing_organization_key = #{publishingOrgKey,jdbcType=OTHER}
    </if>
    <where>
      <if test="publishingCountry != null">AND ds.publishing_organization_country = #{publishingCountry,jdbcType=OTHER}</if>
      <if test="datasetKey != null">AND ds.dataset_key = #{datasetKey,jdbcType=OTHER}</if>
      <if test="type != null">AND ds.type = #{type,jdbcType=OTHER}</if>
      <if test="fromDate != null"><![CDATA[AND ds.year_month >= #{fromDate,jdbcType=TIMESTAMP}]]></if>
      <if test="toDate != null"><![CDATA[AND ds.year_month < #{toDate,jdbcType=TIMESTAMP}]]></if>
    </where>
    GROUP BY ds.dataset_key, ds.year_month
    ORDER BY ds.year_month DESC
    <if test="page != null" >
    LIMIT #{page.limit} OFFSET #{page.offset}
    </if>
  </select>

  <select id="countDownloadStatistics" resultType="Long" parameterType="map">
    SELECT COUNT(*)
    FROM download_statistics ds
    <if test="publishingOrgKey != null">
      JOIN dataset d ON d.key = ds.dataset_key AND d.publishing_organization_key = #{publishingOrgKey,jdbcType=OTHER}
    </if>
    <where>
      <if test="publishingCountry != null">AND ds.publishing_organization_country = #{publishingCountry,jdbcType=OTHER}</if>
      <if test="datasetKey != null">AND ds.dataset_key = #{datasetKey,jdbcType=OTHER}</if>
      <if test="type != null">AND ds.type = #{type,jdbcType=OTHER}</if>
      <if test="fromDate != null"><![CDATA[AND ds.year_month >= #{fromDate,jdbcType=TIMESTAMP}]]></if>
      <if test="toDate != null"><![CDATA[AND ds.year_month < #{toDate,jdbcType=TIMESTAMP}]]></if>
    </where>
  </select>


  <insert id="updateDownloadStats" parameterType="map">
    INSERT INTO download_statistics (year_month, publishing_organization_country, dataset_key, total_records, number_downloads, type) (
    SELECT date_trunc('month', oc.created) AS year_month, COALESCE(o.country,'ZZ') AS publishing_organization_country, dod.dataset_key, SUM(dod.number_records) AS total_records, COUNT(dod.download_key) AS number_downloads, #{downloadType}::download_type AS type
    FROM dataset_${downloadType.name().toLowerCase()}_download dod
    JOIN ${downloadType.name().toLowerCase()}_download oc ON oc.key = dod.download_key AND oc.status IN ('SUCCEEDED','FILE_ERASED')
    AND <![CDATA[oc.created >= #{fromDate,jdbcType=TIMESTAMP} AND oc.created < #{toDate,jdbcType=TIMESTAMP}]]>
    JOIN dataset d ON dod.dataset_key = d.key
    JOIN organization o ON d.publishing_organization_key = o.key
    GROUP BY year_month, dod.dataset_key, o.country, oc.type ORDER BY dataset_key, publishing_organization_country
    ) ON CONFLICT ON CONSTRAINT download_statistics_pkey
    DO UPDATE SET (year_month, publishing_organization_country, dataset_key, total_records, number_downloads, type) =
    (EXCLUDED.year_month, EXCLUDED.publishing_organization_country, EXCLUDED.dataset_key, EXCLUDED.total_records, EXCLUDED.number_downloads, EXCLUDED.type)
  </insert>

  <insert id="updateDownloadUserStats" parameterType="map">
    INSERT INTO download_user_statistics (year_month, user_country, total_records, number_downloads, type) (
    SELECT date_trunc('month', oc.created) AS year_month, COALESCE(u.settings->'country','ZZ') AS user_country, SUM(oc.total_records) AS total_records, COUNT(oc.key) AS number_downloads, #{downloadType}::download_type AS type
    FROM ${downloadType.name().toLowerCase()}_download oc
    JOIN "user" u ON oc.created_by = u.username
    WHERE oc.status IN ('SUCCEEDED','FILE_ERASED')
    AND <![CDATA[oc.created >= #{fromDate,jdbcType=TIMESTAMP} AND oc.created < #{toDate,jdbcType=TIMESTAMP}]]>
    GROUP BY year_month, user_country, oc.type ORDER BY year_month, user_country
    ) ON CONFLICT ON CONSTRAINT download_user_statistics_pkey
    DO UPDATE SET (year_month, user_country, total_records, number_downloads, type) =
    (EXCLUDED.year_month, EXCLUDED.user_country, EXCLUDED.total_records, EXCLUDED.number_downloads, EXCLUDED.type)
  </insert>

  <insert id="updateDownloadSourceStats" parameterType="map">
    INSERT INTO download_source_statistics (year_month, source, total_records, number_downloads, type) (
    SELECT date_trunc('month', oc.created) AS year_month, COALESCE(oc.source,'UNKNOWN') AS source, SUM(oc.total_records) AS total_records, COUNT(oc.key) AS number_downloads, #{downloadType}::download_type AS type
    FROM ${downloadType.name().toLowerCase()}_download oc
    WHERE oc.status IN ('SUCCEEDED','FILE_ERASED')
    AND <![CDATA[oc.created >= #{fromDate,jdbcType=TIMESTAMP} AND oc.created < #{toDate,jdbcType=TIMESTAMP}]]>
    GROUP BY year_month, oc.source, oc.type ORDER BY year_month, oc.source
    ) ON CONFLICT ON CONSTRAINT download_source_statistics_pkey
    DO UPDATE SET (year_month, source, total_records, number_downloads, type) =
    (EXCLUDED.year_month, EXCLUDED.source, EXCLUDED.total_records, EXCLUDED.number_downloads, EXCLUDED.type)
  </insert>
</mapper>
