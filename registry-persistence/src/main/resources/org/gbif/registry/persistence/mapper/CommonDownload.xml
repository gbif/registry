<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="org.gbif.registry.persistence.mapper.CommonDownload">

  <!-- Maps an occurrence download and handles the different types of downloads -->
  <resultMap id="OCCURRENCE_DOWNLOAD_MAP_BASIC" type="org.gbif.api.model.occurrence.Download" autoMapping="false">
    <id property="key" column="key"/>
    <result property="doi" column="doi" />
    <result property="license" column="license"/>
    <result property="status" column="status"/>
    <result property="downloadLink" column="download_link"/>
    <result property="size" column="size"/>
    <result property="totalRecords" column="total_records"/>
    <result property="created" column="created"/>
    <result property="modified" column="modified"/>
    <result property="eraseAfter" column="erase_after"/>
    <result property="erasureNotification" column="erasure_notification"/>
    <result property="source" column="source"/>

    <association property="request" javaType="org.gbif.api.model.occurrence.DownloadRequest">
      <result property="notificationAddressesAsString" column="notification_addresses"/>
      <result property="sendNotification" column="send_notification"/>
      <result property="creator" column="created_by" />
      <result property="format" column="format"/>
      <result property="type" column="type"/>
      <result property="machineDescription" column="machine_description" typeHandler="org.gbif.registry.persistence.mapper.handler.MachineDescriptorTypeHandler"/>
      <result property="description" column="description" />
      <result property="checklistKey" column="checklist_key"/>
      <discriminator javaType="string" column="format">
        <case value="DWCA" resultType="org.gbif.api.model.occurrence.PredicateDownloadRequest">
          <result property="predicate" column="filter" typeHandler="org.gbif.registry.persistence.mapper.handler.PredicateTypeHandler" />
          <result property="verbatimExtensions" column="verbatim_extensions" typeHandler="ExtensionArrayTypeHandler"/>
        </case>
        <case value="SIMPLE_CSV" resultType="org.gbif.api.model.occurrence.PredicateDownloadRequest">
          <result property="predicate" column="filter" typeHandler="org.gbif.registry.persistence.mapper.handler.PredicateTypeHandler" />
          <result property="verbatimExtensions" column="verbatim_extensions" typeHandler="ExtensionArrayTypeHandler"/>
        </case>
        <case value="SIMPLE_AVRO" resultType="org.gbif.api.model.occurrence.PredicateDownloadRequest">
          <result property="predicate" column="filter" typeHandler="org.gbif.registry.persistence.mapper.handler.PredicateTypeHandler" />
          <result property="verbatimExtensions" column="verbatim_extensions" typeHandler="ExtensionArrayTypeHandler"/>
        </case>
        <case value="SIMPLE_PARQUET" resultType="org.gbif.api.model.occurrence.PredicateDownloadRequest">
          <result property="predicate" column="filter" typeHandler="org.gbif.registry.persistence.mapper.handler.PredicateTypeHandler" />
          <result property="verbatimExtensions" column="verbatim_extensions" typeHandler="ExtensionArrayTypeHandler"/>
        </case>
        <case value="SIMPLE_WITH_VERBATIM_AVRO" resultType="org.gbif.api.model.occurrence.PredicateDownloadRequest">
          <result property="predicate" column="filter" typeHandler="org.gbif.registry.persistence.mapper.handler.PredicateTypeHandler" />
          <result property="verbatimExtensions" column="verbatim_extensions" typeHandler="ExtensionArrayTypeHandler"/>
        </case>
        <case value="SPECIES_LIST" resultType="org.gbif.api.model.occurrence.PredicateDownloadRequest">
          <result property="predicate" column="filter" typeHandler="org.gbif.registry.persistence.mapper.handler.PredicateTypeHandler" />
          <result property="verbatimExtensions" column="verbatim_extensions" typeHandler="ExtensionArrayTypeHandler"/>
        </case>
        <case value="MAP_OF_LIFE" resultType="org.gbif.api.model.occurrence.PredicateDownloadRequest">
          <result property="predicate" column="filter" typeHandler="org.gbif.registry.persistence.mapper.handler.PredicateTypeHandler" />
          <result property="verbatimExtensions" column="verbatim_extensions" typeHandler="ExtensionArrayTypeHandler"/>
        </case>
        <case value="BIONOMIA" resultType="org.gbif.api.model.occurrence.PredicateDownloadRequest">
          <result property="predicate" column="filter" typeHandler="org.gbif.registry.persistence.mapper.handler.PredicateTypeHandler" />
          <result property="verbatimExtensions" column="verbatim_extensions" typeHandler="ExtensionArrayTypeHandler"/>
        </case>
        <case value="SQL_TSV_ZIP" resultType="org.gbif.api.model.occurrence.SqlDownloadRequest">
          <result property="sql" column="filter" />
        </case>
      </discriminator>
    </association>
  </resultMap>

  <resultMap id="DATASET_OCCURRENCE_OMIT_DOWNLOAD_MAP" type="org.gbif.api.model.registry.DatasetOccurrenceDownloadUsage" autoMapping="false">
    <id property="downloadKey" column="download_key"/>
    <id property="datasetKey" column="dataset_key"/>
    <result property="datasetTitle" column="dataset_title"/>
    <result property="datasetDOI" column="dataset_doi"/>
    <result property="datasetCitation" column="dataset_citation"/>
    <result property="numberRecords" column="number_records"/>
    <result property="publishingCountryCode" column="country"/>
    <!-- The download is null -->
  </resultMap>

  <resultMap id="ORGANIZATION_OCCURRENCE_DOWNLOAD_MAP" type="org.gbif.api.model.registry.OrganizationOccurrenceDownloadUsage" autoMapping="false">
    <id property="downloadKey" column="download_key"/>
    <id property="organizationKey" column="organizationKey"/>
    <result property="organizationTitle" column="organizationTitle"/>
    <result property="numberRecords" column="numberRecords"/>
    <result property="publishingCountryCode" column="publishingCountryCode"/>
  </resultMap>

  <resultMap id="COUNTRY_OCCURRENCE_DOWNLOAD_MAP" type="org.gbif.api.model.registry.CountryOccurrenceDownloadUsage" autoMapping="false">
    <id property="downloadKey" column="download_key"/>
    <id property="publishingCountryCode" column="publishingCountryCode"/>
    <result property="numberRecords" column="numberRecords"/>
  </resultMap>

  <sql id="DATASET_OCCURRENCE_DOWNLOAD_FIELDS">
    dod.download_key,dod.dataset_key,dod.dataset_title,dod.dataset_doi,dod.dataset_citation,dod.number_records
  </sql>

  <sql id="OCCURRENCE_DOWNLOAD_FIELDS">
    key,doi,license,filter,status,download_link,size,total_records,notification_addresses,created_by,send_notification,
    format,created,modified,erase_after,erasure_notification,verbatim_extensions,source, description, machine_description,
    checklist_key
  </sql>

  <sql id="COUNT_DATASETS_QUERY">
    SELECT COUNT(*) FROM dataset_${downloadTable}_download WHERE download_key = #{key,jdbcType=VARCHAR}
  </sql>

  <sql id="COUNT_ORGANIZATIONS_QUERY">
    SELECT COUNT(DISTINCT o.key)
    FROM dataset_${downloadTable}_download dod
    INNER JOIN dataset d ON dod.dataset_key= d.key
    INNER JOIN organization o ON d.publishing_organization_key = o.key
    WHERE dod.download_key = #{key,jdbcType=VARCHAR}
  </sql>

  <sql id="COUNT_PUBLISHING_COUNTRIES_QUERY">
    SELECT COUNT(DISTINCT o.country)
    FROM dataset_${downloadTable}_download dod
    INNER JOIN dataset d ON dod.dataset_key= d.key
    INNER JOIN organization o ON d.publishing_organization_key = o.key
    WHERE dod.download_key = #{key,jdbcType=VARCHAR}
  </sql>

  <!--
  Only the below fields can be updated
  -->
  <sql id="OCCURRENCE_DOWNLOAD_UPDATE_NOTIFICATION_ADDRESSES">
    notification_addresses = #{notificationAddressesAsString,jdbcType=VARCHAR},
    created_by = #{newCreator,jdbcType=VARCHAR}
  </sql>

  <!--
    Only the below fields can be updated
   -->
  <sql id="OCCURRENCE_DOWNLOAD_UPDATE_STATUS">
    status = #{status,jdbcType=OTHER},
    size = #{size,jdbcType=BIGINT},
    doi = #{doi,jdbcType=VARCHAR},
    total_records = #{totalRecords,jdbcType=INTEGER},
    license = #{license,jdbcType=OTHER},
    erase_after = #{eraseAfter,jdbcType=TIMESTAMP},
    erasure_notification = #{erasureNotification,jdbcType=TIMESTAMP},
    download_link = #{downloadLink,jdbcType=VARCHAR},
    modified = now()
  </sql>

  <sql id="OCCURRENCE_DOWNLOAD_FIELD_TYPES">
    #{key,jdbcType=VARCHAR},
    #{doi,jdbcType=VARCHAR},
    #{license,jdbcType=OTHER},
    <choose>
      <when test="request.format.name().equals('SQL_TSV_ZIP')"> #{request.sql,jdbcType=VARCHAR},</when>
      <otherwise>#{request.predicate,jdbcType=VARCHAR,typeHandler=org.gbif.registry.persistence.mapper.handler.PredicateTypeHandler},</otherwise>
    </choose>
    #{status,jdbcType=OTHER},
    #{downloadLink,jdbcType=VARCHAR},
    #{size,jdbcType=BIGINT},
    #{totalRecords,jdbcType=INTEGER},
    #{request.notificationAddressesAsString,jdbcType=VARCHAR},
    #{request.creator,jdbcType=VARCHAR},
    #{request.sendNotification,jdbcType=BOOLEAN},
    #{request.format,jdbcType=OTHER},
    now(), <!-- created -->
    now(), <!-- modified -->
    #{eraseAfter,jdbcType=TIMESTAMP},
    #{erasureNotification,jdbcType=TIMESTAMP},
    <choose>
      <when test="request.format.name().equals('SQL_TSV_ZIP')">NULL,</when>
      <otherwise>#{request.verbatimExtensions,jdbcType=ARRAY,typeHandler=ExtensionArrayTypeHandler},</otherwise>
    </choose>
    #{source,jdbcType=VARCHAR},
    #{request.description, jdbcType=VARCHAR},
    #{request.machineDescription,jdbcType=OTHER,typeHandler=org.gbif.registry.persistence.mapper.handler.MachineDescriptorTypeHandler}::jsonb,
    #{request.checklistKey, jdbcType=VARCHAR}
  </sql>

  <sql id="LIST_BY_USER_QUERY">
    SELECT <include refid="OCCURRENCE_DOWNLOAD_FIELDS"/>
    FROM ${downloadTable}_download
    <include refid="LIST_BY_USER_COMMON" />
    ORDER BY created DESC, key
    <if test="page != null" >
      LIMIT #{page.limit} OFFSET #{page.offset}
    </if>
  </sql>

  <sql id="LIST_BY_USER_LIGHTWEIGHT_QUERY">
    SELECT <include refid="OCCURRENCE_DOWNLOAD_FIELDS"/>
    FROM ${downloadTable}_download
    <include refid="LIST_BY_USER_COMMON" />
    ORDER BY created DESC, key
    <if test="page != null" >
      LIMIT #{page.limit} OFFSET #{page.offset}
    </if>
  </sql>

  <sql id="LIST_BY_USER_COMMON">
    WHERE created_by = #{creator,jdbcType=VARCHAR}
    <if test="status != null and !status.isEmpty()" >
      AND status IN
      <foreach item="item" index="index" collection="status"
               open="(" separator="," close=")">
        #{item}
      </foreach>
    </if>
    <if test="from != null">
      AND created >= #{from}
    </if>
  </sql>

  <!-- Append safe ordering -->
  <sql id="LIST_QUERY">
    SELECT <include refid="OCCURRENCE_DOWNLOAD_FIELDS"/>
    FROM ${downloadTable}_download
    <include refid="LIST_WHERE"/>
    ORDER BY created DESC, key
    <if test="page != null" >
      LIMIT #{page.limit} OFFSET #{page.offset}
    </if>
  </sql>

  <sql id="LIST_WHERE">
    <where>
      <if test="status != null and status.size > 0">
        status IN
        <foreach item="item" index="index" collection="status" open="(" separator="," close=")">
          #{item}
        </foreach>
      </if>
      <if test="source != null"> AND source = #{source,jdbcType=OTHER}</if>
    </where>
  </sql>

  <sql id="LIST_BY_ERASE_AFTER_QUERY">
    SELECT <include refid="OCCURRENCE_DOWNLOAD_FIELDS"/>
    FROM ${downloadTable}_download
    <include refid="LIST_BY_ERASE_AFTER_WHERE"/>
    ORDER BY created DESC, key
    <if test="page != null" >
      LIMIT #{page.limit} OFFSET #{page.offset}
    </if>
  </sql>

  <sql id="LIST_BY_ERASE_AFTER_WHERE">
    WHERE status = 'SUCCEEDED'
    AND created_by NOT IN ('download.gbif.org')
    <choose>
      <when test="eraseAfter != null" >
        AND <![CDATA[erase_after < #{eraseAfter,jdbcType=TIMESTAMP}]]>
      </when>
      <otherwise>
        AND <![CDATA[erase_after < NOW()]]>
      </otherwise>
    </choose>

    <if test="size != null" >
      AND <![CDATA[size >= #{size,jdbcType=BIGINT}]]>
    </if>

    <choose>
      <when test="erasureNotification != null" >
        AND <![CDATA[erasure_notification < #{erasureNotification,jdbcType=TIMESTAMP}]]>
      </when>
      <otherwise>
        AND erasure_notification IS NULL
      </otherwise>
    </choose>
  </sql>

  <sql id="LIST_BY_DATASET_COMMON">
    WHERE dataset_key = #{datasetKey,jdbcType=OTHER}
    <!-- This is preferable to joining to the occurrence_download table to ORDER BY created DESC. -->
    ORDER BY RIGHT(download_key, 15) DESC, LEFT(download_key, 7) DESC
    <if test="page != null" >
      LIMIT #{page.limit} OFFSET #{page.offset}
    </if>
  </sql>

  <sql id="LIST_BY_DOWNLOAD_QUERY">
    SELECT <include refid="DATASET_OCCURRENCE_DOWNLOAD_FIELDS"/>,o.country
    FROM dataset_${downloadTable}_download dod
    INNER JOIN dataset d ON d.key = dod.dataset_key
    INNER JOIN organization o ON o.key = d.publishing_organization_key
    WHERE dod.download_key = #{downloadKey,jdbcType=OTHER}
    <if test="datasetTitle != null" >
      AND dod.dataset_title = #{datasetTitle,jdbcType=VARCHAR}
    </if>
    ORDER BY
    <if test="sortBy != null">
      <choose>
        <when test="sortBy.name.equals('DATASET_TITLE')">
          dod.dataset_title
        </when>
        <when test="sortBy.name.equals('COUNTRY_CODE')">
          o.country
        </when>
        <when test="sortBy.name.equals('RECORD_COUNT')">
          dod.number_records
        </when>
        <otherwise/>
      </choose>
      <if test="sortOrder != null">
        <choose>
          <when test="sortOrder.name.equals('DESC')">
            DESC
          </when>
          <otherwise>
            ASC
          </otherwise>
        </choose>
      </if>
      ,
    </if>
    dod.number_records DESC, dod.dataset_key
    <if test="page != null" >
      LIMIT #{page.limit} OFFSET #{page.offset}
    </if>
  </sql>

  <sql id="LIST_ORGANIZATIONS_BY_DOWNLOAD_QUERY">
    SELECT o.key AS organizationKey, o.title AS organizationTitle, o.country AS publishingCountryCode, dod.download_key,
    SUM(dod.number_records) AS numberRecords
    FROM dataset_${downloadTable}_download dod
    INNER JOIN dataset d on d.key = dod.dataset_key
    INNER JOIN organization o ON o.key = d.publishing_organization_key
    WHERE dod.download_key = #{downloadKey,jdbcType=OTHER}
    <if test="organizationTitle != null" >
      AND o.title = #{organizationTitle,jdbcType=VARCHAR}
    </if>
    GROUP BY o.key, o.title, o.country, dod.download_key
    ORDER BY
    <if test="sortBy != null">
      <choose>
        <when test="sortBy.name.equals('ORGANIZATION_TITLE')">
          o.title
        </when>
        <when test="sortBy.name.equals('COUNTRY_CODE')">
          o.country
        </when>
        <when test="sortBy.name.equals('RECORD_COUNT')">
          numberRecords
        </when>
        <otherwise/>
      </choose>
      <if test="sortOrder != null">
        <choose>
          <when test="sortOrder.name.equals('DESC')">
            DESC
          </when>
          <otherwise>
            ASC
          </otherwise>
        </choose>
      </if>
      ,
    </if>
    o.key
    <if test="page != null" >
      LIMIT #{page.limit} OFFSET #{page.offset}
    </if>
  </sql>

  <sql id="LIST_COUNTRIES_BY_DOWNLOAD">
    SELECT o.country AS publishingCountryCode, dod.download_key, SUM(dod.number_records) AS numberRecords
    FROM dataset_${downloadTable}_download dod
    INNER JOIN dataset d on d.key = dod.dataset_key
    INNER JOIN organization o ON o.key = d.publishing_organization_key
    WHERE dod.download_key = #{downloadKey,jdbcType=OTHER}
    GROUP BY o.country, dod.download_key
    ORDER BY
    <if test="sortBy != null">
      <choose>
        <when test="sortBy.name.equals('COUNTRY_CODE')">
          o.country
        </when>
        <when test="sortBy.name.equals('RECORD_COUNT')">
          numberRecords
        </when>
        <otherwise/>
      </choose>
      <if test="sortOrder != null">
        <choose>
          <when test="sortOrder.name.equals('DESC')">
            DESC
          </when>
          <otherwise>
            ASC
          </otherwise>
        </choose>
      </if>
      ,
    </if>
    o.country
    <if test="page != null" >
      LIMIT #{page.limit} OFFSET #{page.offset}
    </if>
  </sql>

  <sql id="COUNT_ORGANIZATIONS_BY_DOWNLOAD_QUERY">
    SELECT COUNT(DISTINCT o.key)
    FROM dataset_${downloadTable}_download dod
    INNER JOIN dataset d on d.key = dod.dataset_key
    INNER JOIN organization o ON o.key = d.publishing_organization_key
    WHERE dod.download_key = #{downloadKey,jdbcType=OTHER}
    <if test="organizationTitle != null" >
      AND o.title = #{organizationTitle,jdbcType=VARCHAR}
    </if>
  </sql>

  <sql id="COUNT_COUNTRIES_BY_DOWNLOAD_QUERY">
    SELECT COUNT(DISTINCT o.country)
    FROM dataset_${downloadTable}_download dod
    INNER JOIN dataset d on d.key = dod.dataset_key
    INNER JOIN organization o ON o.key = d.publishing_organization_key
    WHERE dod.download_key = #{downloadKey,jdbcType=OTHER}
  </sql>

  <sql id="COUNT_BY_DATASET_QUERY">
    SELECT COUNT(DISTINCT download_key)
    FROM dataset_${downloadTable}_download
    WHERE dataset_key = #{datasetKey,jdbcType=OTHER}
  </sql>

  <sql id="CREATE_OR_UPDATE_USAGES_QUERY">
    WITH
    dataset_usages(dataset_key, number_records) AS
    ((VALUES
    <foreach item="value" index="key" collection="citationMap" open="(" separator="),(" close=")">
      cast(#{key} as uuid),#{value}
    </foreach>
    ))
    INSERT INTO dataset_${downloadTable}_download (
    SELECT #{downloadKey} as download_key, d.key, dus.number_records, d.title, d.doi, d.citation
    FROM dataset d
    JOIN dataset_usages dus ON d.key = dus.dataset_key)
    ON CONFLICT(download_key,dataset_key) DO UPDATE SET number_records = EXCLUDED.number_records
  </sql>

</mapper>
