<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="org.gbif.registry.persistence.mapper.collections.CollectionsSearchMapper">

  <!-- Auto-mapping and eager loading of sub resources  -->
  <resultMap id="SEARCH_DTO_MAP" type="SearchDto" autoMapping="true"/>
  <resultMap id="FACET_DTO_MAP" type="FacetDto" autoMapping="true"/>

  <sql id="INSTITUTION_READ_FIELDS">
    i.key, i.code, i.name, i.description, i.alternative_codes,
    i.display_on_NHCPortal AS displayOnNHCPortal,'institution' AS type,
    i.address_key, i.mailing_address_key, null::uuid institution_key, null institution_name, null institution_code
  </sql>

  <sql id="COLLECTION_READ_FIELDS">
    c.key, c.code, c.name, c.description, c.alternative_codes,
    c.display_on_NHCPortal AS displayOnNHCPortal,'collection' AS type,
    c.address_key, c.mailing_address_key, i.key institution_key, i.name institution_name, i.code institution_code
  </sql>

  <sql id="TS_QUERY">
    to_tsquery('english',regexp_replace(quote_literal(unaccent(trim(#{params.query}))),'\s+',':*&amp;','g')||':*')
  </sql>

  <select id="search" resultMap="SEARCH_DTO_MAP">
    SELECT <if test="params.query != null">matches.score,</if> matches.type, matches.key, matches.code, matches.name,
    matches.institution_key, matches.institution_code, matches.institution_name, matches.displayOnNHCPortal,
    ad.country country, mail.country mail_country
    <if test="params.query != null &amp;&amp; params.highlight">
      ,ts_headline(matches.code, query) code_highlight, ts_headline(matches.name, query) name_highlight
      ,ts_headline(matches.description, query) description_highlight
      ,ts_headline(array_to_string(akeys(matches.alternative_codes), ' '), query) alternative_codes_highlight
      ,ts_headline(ad.address, query) address_highlight,ts_headline(ad.city, query) city_highlight
      ,ts_headline(ad.province, query) province_highlight,ts_headline(ad.country, query) country_highlight
      ,ts_headline(mail.address, query) mail_address_highlight,ts_headline(mail.city, query) mail_city_highlight
      ,ts_headline(mail.province, query) mail_province_highlight, ts_headline(mail.country, query)
      mail_country_highlight, matches.similarity_match
    </if>
    FROM (
    <trim prefixOverrides="UNION ALL">
      <if test="params.type == null or params.type.equals('INSTITUTION')">
        (
        SELECT DISTINCT ON (<if test="params.query != null">ts_rank_cd(i.fulltext_search, query),</if>i.created, i.key)
        <include refid="INSTITUTION_READ_FIELDS"/>, false AS similarity_match
        <if test="params.query != null">,ts_rank_cd(i.fulltext_search, query) score, query</if>
        FROM institution i
        <if test="params.query != null">
          INNER JOIN
          <include refid="TS_QUERY"/>
          AS query ON query @@ fulltext_search
        </if>
        WHERE i.deleted IS NULL
        <include refid="org.gbif.registry.persistence.mapper.collections.Common.MULTIVALUE_BOOLEAN_FILTER">
          <property name="values" value="params.displayOnNHCPortal"/>
          <property name="field" value="i.display_on_NHCPortal"/>
        </include>
        )
        <if test="params.query != null">
          UNION ALL
          (
          SELECT DISTINCT ON (i.key)
          <include refid="INSTITUTION_READ_FIELDS"/>, false AS similarity_match
          <if test="params.query != null">
            ,9 AS score,
            <include refid="TS_QUERY"/>
            query
          </if>
          FROM institution i
          WHERE i.deleted IS NULL AND i.code = trim(#{params.query})
          <include refid="org.gbif.registry.persistence.mapper.collections.Common.MULTIVALUE_BOOLEAN_FILTER">
            <property name="values" value="params.displayOnNHCPortal"/>
            <property name="field" value="i.display_on_NHCPortal"/>
          </include>
          )
        </if>
        <if test="params.query != null">
          UNION ALL
          (
          SELECT DISTINCT ON (i.key)
          <include refid="INSTITUTION_READ_FIELDS"/>, true AS similarity_match
          <if test="params.query != null">
            ,similarity(i.name, #{params.query}) AS score,
            <include refid="TS_QUERY"/>
            query
          </if>
          FROM institution i
          WHERE i.deleted IS NULL AND similarity(i.name, #{params.query}) >= 0.65
          <include refid="org.gbif.registry.persistence.mapper.collections.Common.MULTIVALUE_BOOLEAN_FILTER">
            <property name="values" value="params.displayOnNHCPortal"/>
            <property name="field" value="i.display_on_NHCPortal"/>
          </include>
          )
        </if>
      </if>
      <if test="params.type == null or params.type.equals('COLLECTION')">
        UNION ALL
        (
        SELECT DISTINCT ON (<if test="params.query != null">ts_rank_cd(c.fulltext_search, query),</if>c.created, c.key)
        <include refid="COLLECTION_READ_FIELDS"/>, false AS similarity_match
        <if test="params.query != null">,ts_rank_cd(c.fulltext_search, query) score, query</if>
        FROM collection c
        <if test="params.query != null">
          INNER JOIN
          <include refid="TS_QUERY"/>
          AS query ON query @@ fulltext_search
        </if>
        LEFT JOIN institution i ON i.key = c.institution_key
        WHERE c.deleted IS NULL
        <include refid="org.gbif.registry.persistence.mapper.collections.Common.MULTIVALUE_BOOLEAN_FILTER">
          <property name="values" value="params.displayOnNHCPortal"/>
          <property name="field" value="c.display_on_NHCPortal"/>
        </include>
        )
        <if test="params.query != null">
          UNION ALL
          (
          SELECT DISTINCT ON (c.key)
          <include refid="COLLECTION_READ_FIELDS"/>, false AS similarity_match
          <if test="params.query != null">
            ,9 AS score,
            <include refid="TS_QUERY"/>
            query
          </if>
          FROM collection c
          LEFT JOIN institution i ON i.key = c.institution_key
          WHERE c.deleted IS NULL AND c.code = trim(#{params.query})
          <include refid="org.gbif.registry.persistence.mapper.collections.Common.MULTIVALUE_BOOLEAN_FILTER">
            <property name="values" value="params.displayOnNHCPortal"/>
            <property name="field" value="c.display_on_NHCPortal"/>
          </include>
          )
        </if>
        <if test="params.query != null">
          UNION ALL
          (
          SELECT DISTINCT ON (c.key)
          <include refid="COLLECTION_READ_FIELDS"/>, true AS similarity_match
          <if test="params.query != null">
            ,similarity(c.name, #{params.query}) AS score,
            <include refid="TS_QUERY"/>
            query
          </if>
          FROM collection c
          LEFT JOIN institution i ON i.key = c.institution_key
          WHERE c.deleted IS NULL AND similarity(c.name, #{params.query}) >= 0.65
          <include refid="org.gbif.registry.persistence.mapper.collections.Common.MULTIVALUE_BOOLEAN_FILTER">
            <property name="values" value="params.displayOnNHCPortal"/>
            <property name="field" value="c.display_on_NHCPortal"/>
          </include>
          )
        </if>
      </if>
    </trim>
    ) AS matches
    LEFT JOIN address ad ON ad.key = matches.address_key
    LEFT JOIN address mail ON mail.key = matches.mailing_address_key
    <where>
      <if test="params.country != null and params.country.size > 0">
        AND (ad.country IN
        <foreach item="item" collection="params.country" open="(" separator="," close=")">
          #{item,jdbcType=VARCHAR}
        </foreach>
        OR mail.country IN
        <foreach item="item" collection="params.country" open="(" separator="," close=")">
          #{item,jdbcType=VARCHAR}
        </foreach>
        )
      </if>
    </where>
    <if test="params.query != null">
      ORDER BY matches.score DESC
    </if>
    <if test="params.limit != null">
      LIMIT #{params.limit}
    </if>
  </select>

  <resultMap id="INSTITUTION_DTO_MAP" type="InstitutionSearchDto" autoMapping="true">
    <id property="key" column="key"/>
    <result property="disciplines" column="discipline" typeHandler="StringArrayTypeHandler"/>
    <result property="alternativeCodes" column="alternative_codes" typeHandler="AlternativeCodesTypeHandler"/>
    <result property="types" column="type" typeHandler="StringArrayTypeHandler"/>
    <result property="institutionalGovernances" column="institutional_governance" typeHandler="StringArrayTypeHandler"/>
  </resultMap>

  <select id="searchInstitutions" resultType="InstitutionSearchDto" resultMap="INSTITUTION_DTO_MAP"
          parameterType="Pageable">
    SELECT * FROM(
    SELECT DISTINCT ON (
    <if test="params.query != null">ts_rank_cd(i.fulltext_search, query),</if>
    <if test="params.fuzzyName != null">similarity_score,</if>
    i.created, i.key)
    <include refid="org.gbif.registry.persistence.mapper.collections.InstitutionMapper.INSTITUTION_READ_FIELDS"/>,
    addr.country AS country, mail_addr.country AS mailingCountry,
    addr.city AS city, mail_addr.city AS mailingCity, i.fulltext_search
    <if test="params.query != null &amp;&amp; params.highlight">
      ,ts_headline(i.code, query) code_highlight, ts_headline(i.name, query) name_highlight
      ,ts_headline(i.description, query) description_highlight
      ,ts_headline(array_to_string(akeys(i.alternative_codes), ' '), query) alternative_codes_highlight
      ,ts_headline(addr.address, query) address_highlight,ts_headline(addr.city, query) city_highlight
      ,ts_headline(addr.province, query) province_highlight,ts_headline(addr.country, query) country_highlight
      ,ts_headline(mail_addr.address, query) mail_address_highlight,ts_headline(mail_addr.city, query) mail_city_highlight
      ,ts_headline(mail_addr.province, query) mail_province_highlight,
      ts_headline(mail_addr.country, query) mail_country_highlight,
      null AS descriptor_usage_name_highlight,
      null AS descriptor_country_highlight,
      null AS descriptor_identified_by_highlight,
      null AS descriptor_type_status_highlight,
      null AS descriptor_recorded_by_highlight,
      null AS descriptor_discipline_highlight,
      null AS descriptor_object_classification_highlight,
      null AS descriptor_issues_highlight
    </if>
    <if test="params.query != null">,query</if>
    <if test="params.fuzzyName != null">,similar_name_score(i.name, #{params.fuzzyName,jdbcType=ARRAY,typeHandler=StringArrayTypeHandler}::text[]) AS similarity_score
    </if>
    FROM institution i
    <if test="params.query != null" >
      <include refid="INSTITUTIONS_FULLTEXT_SEARCH"/>
    </if>
    <include refid="org.gbif.registry.persistence.mapper.collections.InstitutionMapper.LIST_FILTER"/>
    ) AS i
    ORDER BY
    <include refid="org.gbif.registry.persistence.mapper.collections.Common.sortBy">
      <property name="alias" value="i."/>
    </include>
    <if test="params.query != null">ts_rank_cd(i.fulltext_search, query) DESC,</if>
    <if test="params.fuzzyName != null">similarity_score DESC,</if>
    i.created DESC, i.key
    <if test="params.page != null">
      LIMIT #{params.page.limit} OFFSET #{params.page.offset}
    </if>
  </select>

  <select id="countInstitutions" resultType="Long">
    SELECT count(DISTINCT i.key)
    FROM institution i
    <if test="params.query != null" >
      <include refid="INSTITUTIONS_FULLTEXT_SEARCH"/>
    </if>
    <include refid="org.gbif.registry.persistence.mapper.collections.InstitutionMapper.LIST_FILTER"/>
  </select>

  <sql id="INSTITUTIONS_FULLTEXT_SEARCH">
    JOIN to_tsquery('english',regexp_replace(quote_literal(unaccent(trim(#{params.query}))),'\s+',':*&amp;','g')||':*') AS query ON query @@ fulltext_search
    OR EXISTS(
    SELECT collection_contact_key
    FROM institution_collection_contact JOIN collection_contact cc ON cc.key = collection_contact_key
    WHERE institution_key = i.key AND query @@ cc.fulltext_search
    )
  </sql>

  <resultMap id="COLLECTION_DTO_MAP" type="CollectionSearchDto" autoMapping="true">
    <id property="key" column="key"/>
    <result property="contentTypes" column="content_type" typeHandler="StringArrayTypeHandler"/>
    <result property="preservationTypes" column="preservation_type" typeHandler="StringArrayTypeHandler"/>
    <result property="alternativeCodes" column="alternative_codes" typeHandler="AlternativeCodesTypeHandler"/>
    <result column="descriptorIdentifiedBy" property="descriptorIdentifiedBy" typeHandler="StringArrayTypeHandler"/>
    <result column="descriptorTypeStatus" property="descriptorTypeStatus" typeHandler="StringArrayTypeHandler"/>
    <result column="descriptorRecordedBy" property="descriptorRecordedBy" typeHandler="StringArrayTypeHandler"/>
    <result column="descriptorIssues" property="descriptorIssues" typeHandler="StringArrayTypeHandler"/>
  </resultMap>

  <select id="searchCollections" resultType="CollectionSearchDto" resultMap="COLLECTION_DTO_MAP"
          parameterType="Pageable">
    SELECT c.*
    <if test="params.descriptorSearch or params.descriptorFacet">
      ,cd.key AS descriptorKey, cd.collection_descriptor_group_key AS descriptorGroupKey, cd.usage_key AS descriptorUsageKey,
      cd.usage_name AS descriptorUsageName, cd.usage_rank AS descriptorUsageRank, cd.country AS descriptorCountry,
      cd.individual_count AS descriptorIndividualCount, cd.identified_by AS descriptorIdentifiedBy,
      cd.date_identified as descriptorDateIdentified, cd.type_status AS descriptorTypeStatus,
      cd.recorded_by AS descriptorRecordedBy, cd.discipline AS descriptorDiscipline,
      cd.object_classification_name AS descriptorObjectClassification, cd.issues AS descriptorIssues
    </if>
    <if test="params.query != null &amp;&amp; params.highlight">
      ,ts_headline(c.code, c.query) code_highlight, ts_headline(c.name, c.query) name_highlight
      ,ts_headline(c.description, c.query) description_highlight
      ,ts_headline(array_to_string(akeys(c.alternative_codes), ' '), c.query) alternative_codes_highlight
      ,ts_headline(address, c.query) address_highlight,ts_headline(city, c.query) city_highlight
      ,ts_headline(province, c.query) province_highlight,ts_headline(c.country, c.query) country_highlight
      ,ts_headline(mail_address, c.query) mail_address_highlight,ts_headline(mailingCity, c.query) mail_city_highlight
      ,ts_headline(mail_province, c.query) mail_province_highlight, ts_headline(mailingCountry, c.query)
      mail_country_highlight,
      <if test="params.descriptorSearch or params.descriptorFacet">
        ts_headline(cd.usage_name, c.query) descriptor_usage_name_highlight,
        ts_headline(cd.country, c.query) descriptor_country_highlight,
        ts_headline(array_to_string(cd.identified_by, ' '), c.query) descriptor_identified_by_highlight,
        ts_headline(array_to_string(cd.type_status, ' '), c.query) descriptor_type_status_highlight,
        ts_headline(array_to_string(cd.recorded_by, ' '), c.query) descriptor_recorded_by_highlight,
        ts_headline(cd.discipline, c.query) descriptor_discipline_highlight,
        ts_headline(cd.object_classification_name, c.query) descriptor_object_classification_highlight,
        ts_headline(array_to_string(cd.issues, ' '), c.query) descriptor_issues_highlight,
        ts_headline(cdg.title, c.query) descriptor_group_title_highlight,
        ts_headline(cdg.description, c.query) descriptor_group_description_highlight
      </if>
    </if>
    <if test="params.query != null">
      ,ts_rank_cd(c.fulltext_search, c.query) AS query_rank, ts_rank_cd(cd.fulltext_search, c.query) query_descriptor_rank
    </if>
    <if test="params.query != null">,c.query</if>
    <if test="params.fuzzyName != null">,similar_name_score(c.name, #{params.fuzzyName,jdbcType=ARRAY,typeHandler=StringArrayTypeHandler}::text[]) AS similarity_score
    </if>
    FROM(
    SELECT DISTINCT ON (
    <if test="params.query != null">ts_rank_cd(c.fulltext_search, query), query,</if>
    <if test="params.sortBy != null and params.query == null and params.sortBy.name.equals('NUMBER_SPECIMENS')">
      c.number_specimens,
    </if>
    <if test="params.fuzzyName != null">similarity_score,</if>
    c.created, c.key)
    c.key, c.code, c.name, c.description, c.content_type, c.active, c.personal_collection,
    c.preservation_type, c.accession_status, c.institution_key, c.number_specimens, c.created,
    c.taxonomic_coverage, c.geographic_coverage, c.alternative_codes,
    c.master_source, c.division, c.department, c.display_on_NHCPortal,
    c.occurrence_count, c.type_specimen_count, c.featured_image_url, c.featured_image_license, c.temporal_coverage,
    c.featured_image_attribution,inst.name institutionName, inst.code institutionCode, c.fulltext_search,
    addr.address, addr.province, mail_addr.address AS mail_address, mail_addr.province AS mail_province,
    addr.country AS country, mail_addr.country AS mailingCountry, addr.city AS city, mail_addr.city AS mailingCity
    <if test="params.query != null">, query</if>
    FROM collection c
    <if test="params.descriptorSearch or params.descriptorFacet">
      LEFT JOIN collection_descriptor_group cdg ON cdg.collection_key = c.key AND cdg.deleted IS NULL
      LEFT JOIN collection_descriptor cd ON cd.collection_descriptor_group_key = cdg.key
    </if>
    <if test="params.query != null" >
      <include refid="COLLECTIONS_FULLTEXT_SEARCH"/>
    </if>
    <include refid="org.gbif.registry.persistence.mapper.collections.CollectionMapper.LIST_FILTER"/>
    <include refid="DESCRIPTORS_FILTER"/>
    ORDER BY
    <include refid="org.gbif.registry.persistence.mapper.collections.Common.sortBy">
      <property name="alias" value="c."/>
    </include>
    <if test="params.query != null">ts_rank_cd(c.fulltext_search, query) DESC,</if>
    <if test="params.fuzzyName != null">similarity_score DESC,</if>
    c.created DESC, c.key
    <if test="params.page != null">
      LIMIT #{params.page.limit} OFFSET #{params.page.offset}
    </if>
    ) AS c
    <if test="params.descriptorSearch or params.descriptorFacet">
      LEFT JOIN collection_descriptor_group cdg ON cdg.collection_key = c.key AND cdg.deleted IS NULL
      LEFT JOIN collection_descriptor cd ON cd.collection_descriptor_group_key = cdg.key
    </if>
    <where>
      <include refid="DESCRIPTORS_FILTER"/>
    </where>
  </select>

  <select id="countCollections" resultType="Long">
    SELECT count(DISTINCT c.key)
    FROM collection c
    <if test="params.descriptorSearch or params.descriptorFacet">
      LEFT JOIN collection_descriptor_group cdg ON cdg.collection_key = c.key AND cdg.deleted IS NULL
      LEFT JOIN collection_descriptor cd ON cd.collection_descriptor_group_key = cdg.key
    </if>
    <if test="params.query != null" >
      <include refid="COLLECTIONS_FULLTEXT_SEARCH"/>
    </if>
    <include refid="org.gbif.registry.persistence.mapper.collections.CollectionMapper.LIST_FILTER"/>
    <include refid="DESCRIPTORS_FILTER"/>
  </select>

  <sql id="DESCRIPTORS_FILTER">
    <if test="params.usageKey != null and params.usageKey.size > 0">
      AND cd.usage_key IN
      <foreach item="item" collection="params.usageKey" open="(" separator="," close=")">
        #{item,jdbcType=VARCHAR}
      </foreach>
    </if>
    <if test="params.usageName != null and params.usageName.size > 0">
      AND cd.usage_name IN
      <foreach item="item" collection="params.usageName" open="(" separator="," close=")">
        #{item,jdbcType=VARCHAR}
      </foreach>
    </if>
    <if test="params.usageRank != null and params.usageRank.size > 0">
      AND cd.usage_rank IN
      <foreach item="item" collection="params.usageRank" open="(" separator="," close=")">
        #{item,jdbcType=VARCHAR}
      </foreach>
    </if>
    <if test="params.taxonKey != null  and params.taxonKey.size > 0">
      AND cd.taxon_keys &amp;&amp; ARRAY
      <foreach item="item" collection="params.taxonKey" open="[" separator="," close="]">
        #{item,jdbcType=VARCHAR}
      </foreach>
    </if>
    <include refid="org.gbif.registry.persistence.mapper.collections.Common.MULTIVALUE_RANGE_FIELD_FILTER">
      <property name="values" value="params.individualCount"/>
      <property name="field" value="cd.individual_count"/>
    </include>
    <if test="params.identifiedBy != null and params.identifiedBy.size > 0">
      AND cd.identified_by &amp;&amp; ARRAY
      <foreach item="item" collection="params.identifiedBy" open="[" separator="," close="]">
        #{item,jdbcType=VARCHAR}::text
      </foreach>
    </if>
    <include refid="org.gbif.registry.persistence.mapper.collections.Common.MULTIVALUE_RANGE_FIELD_FILTER">
      <property name="values" value="params.dateIdentified"/>
      <property name="field" value="cd.date_identified"/>
    </include>
    <if test="params.typeStatus != null and params.typeStatus.size > 0">
      AND cd.type_status &amp;&amp; ARRAY
      <foreach item="item" collection="params.typeStatus" open="[" separator="," close="]">
        #{item,jdbcType=VARCHAR}::text
      </foreach>
    </if>
    <if test="params.recordedBy != null and params.recordedBy.size > 0">
      AND cd.recorded_by &amp;&amp; ARRAY
      <foreach item="item" collection="params.recordedBy" open="[" separator="," close="]">
        #{item,jdbcType=VARCHAR}::text
      </foreach>
    </if>
    <if test="params.discipline != null  and params.discipline.size > 0">
      AND cd.discipline IN
      <foreach item="item" collection="params.discipline" open="(" separator="," close=")">
        #{item,jdbcType=VARCHAR}
      </foreach>
    </if>
    <if test="params.objectClassification != null  and params.objectClassification.size > 0">
      AND cd.object_classification_name IN
      <foreach item="item" collection="params.objectClassification" open="(" separator="," close=")">
        #{item,jdbcType=VARCHAR}
      </foreach>
    </if>
    <if test="params.descriptorCountry != null  and params.descriptorCountry.size > 0">
      AND cd.country IN
      <foreach item="item" collection="params.descriptorCountry" open="(" separator="," close=")">
        #{item,jdbcType=VARCHAR}
      </foreach>
    </if>
    <if test="params.issues != null and params.issues.size > 0">
      AND cd.issues &amp;&amp; ARRAY
      <foreach item="item" collection="params.issues" open="[" separator="," close="]">
        #{item,jdbcType=VARCHAR}::text
      </foreach>
    </if>
  </sql>

  <sql id="COLLECTIONS_FULLTEXT_SEARCH">
    JOIN to_tsquery('english',regexp_replace(quote_literal(unaccent(trim(#{params.query}))),'\s+',':*&amp;','g')||':*') AS query ON query @@ c.fulltext_search
    OR EXISTS(
    SELECT collection_contact_key
    FROM collection_collection_contact JOIN collection_contact cc ON cc.key = collection_contact_key
    WHERE collection_key = c.key AND query @@ cc.fulltext_search
    )
    OR <include refid="TS_QUERY"/> @@ cd.fulltext_search
    OR <include refid="TS_QUERY"/> @@ cdg.fulltext_search
  </sql>

  <select id="institutionFacet" resultMap="FACET_DTO_MAP" resultType="FacetDto" parameterType="Pageable">
    <choose>
      <when test="params.facet.name.equals('DISCIPLINE') or params.facet.name.equals('TYPE') or params.facet.name.equals('INSTITUTIONAL_GOVERNANCE')">
        WITH vocabulary_name AS (
          SELECT
            CASE
              WHEN #{params.facet.name} = 'DISCIPLINE' THEN 'Discipline'
              WHEN #{params.facet.name} = 'TYPE' THEN 'InstitutionType'
              WHEN #{params.facet.name} = 'INSTITUTIONAL_GOVERNANCE' THEN 'InstitutionalGovernance'
            END AS vocab_name
        ),
        facet_counts AS (
          SELECT
            vc.name AS facet,
            COUNT(DISTINCT i.key) as count
          FROM institution i
          JOIN institution_concept_links icl ON i.key = icl.institution_key
          JOIN grscicoll_vocab_concept vc ON icl.concept_key = vc.concept_key
          JOIN vocabulary_name vn ON vc.vocabulary_name = vn.vocab_name
          <include refid="org.gbif.registry.persistence.mapper.collections.InstitutionMapper.LIST_FILTER"/>
          AND vc.name IS NOT NULL
          GROUP BY vc.concept_key, vc.name
          <if test="params.facetMinCount != null">
            HAVING COUNT(DISTINCT i.key) >= #{params.facetMinCount}
          </if>
        )
        SELECT facet, count
        FROM facet_counts
        WHERE count > 0  -- Only return facets that have actual data
        ORDER BY count DESC, facet ASC
        <if test="params.facetPage != null">
          LIMIT #{params.facetPage.limit} OFFSET #{params.facetPage.offset}
        </if>
      </when>

      <otherwise>
        SELECT <include refid="INSTITUTION_FACET_FIELDS"/> AS facet, count(DISTINCT i.key)
        FROM institution i
        <if test="params.facet.name.equals('COUNTRY') or params.facet.name.equals('CITY')">
          LEFT JOIN address a ON a.key = i.address_key
          LEFT JOIN address ma ON ma.key = i.mailing_address_key
        </if>
        <include refid="org.gbif.registry.persistence.mapper.collections.InstitutionMapper.LIST_FILTER"/>
        <if test="!params.isArrayFieldFacet and params.facet != null and params.facet.name != null">
          AND <include refid="INSTITUTION_FACET_FIELDS"/> IS NOT NULL
        </if>
        GROUP BY facet
        <if test="params.facetMinCount != null">
          HAVING COUNT(DISTINCT i.key) >= #{params.facetMinCount}
        </if>
        ORDER BY count(DISTINCT i.key) DESC, facet ASC
        <if test="params.facetPage != null">
          LIMIT #{params.facetPage.limit} OFFSET #{params.facetPage.offset}
        </if>
      </otherwise>
    </choose>
  </select>

  <select id="institutionFacetCardinality" resultType="Long">
    <choose>
      <when test="params.facet.name.equals('DISCIPLINE') or params.facet.name.equals('TYPE') or params.facet.name.equals('INSTITUTIONAL_GOVERNANCE')">
        WITH vocabulary_name AS (
          SELECT
            CASE
              WHEN #{params.facet.name} = 'DISCIPLINE' THEN 'Discipline'
              WHEN #{params.facet.name} = 'TYPE' THEN 'InstitutionType'
              WHEN #{params.facet.name} = 'INSTITUTIONAL_GOVERNANCE' THEN 'InstitutionalGovernance'
            END AS vocab_name
        )
        SELECT COUNT(DISTINCT vc.concept_key)
        FROM institution i
        JOIN institution_concept_links icl ON i.key = icl.institution_key
        JOIN grscicoll_vocab_concept vc ON icl.concept_key = vc.concept_key
        JOIN vocabulary_name vn ON vc.vocabulary_name = vn.vocab_name
        <include refid="org.gbif.registry.persistence.mapper.collections.InstitutionMapper.LIST_FILTER"/>
        AND vc.name IS NOT NULL
      </when>

      <otherwise>
        SELECT <include refid="INSTITUTION_FACET_CARDINALITY_FIELDS"/>
        <if test="params.facet.name.equals('COUNTRY') or params.facet.name.equals('CITY')">
          LEFT JOIN address a ON a.key = i.address_key
          LEFT JOIN address ma ON ma.key = i.mailing_address_key
        </if>
        <include refid="org.gbif.registry.persistence.mapper.collections.InstitutionMapper.LIST_FILTER"/>
      </otherwise>
    </choose>
  </select>

  <sql id="INSTITUTION_FACET_FIELDS">
    <choose>
      <when test="params.facet.name.equals('COUNTRY')">
        CASE WHEN a.country is not null THEN a.country ELSE ma.country END
      </when>
      <when test="params.facet.name.equals('CITY')">
        CASE WHEN a.city is not null THEN a.city ELSE ma.city END
      </when>
    </choose>
  </sql>

  <sql id="INSTITUTION_FACET_CARDINALITY_FIELDS">
    <choose>
      <when test="params.facet.name.equals('COUNTRY')">
        COUNT(DISTINCT CASE WHEN a.country is not null THEN a.country ELSE ma.country END)
        FROM institution i
      </when>
      <when test="params.facet.name.equals('CITY')">
        COUNT(DISTINCT CASE WHEN a.city is not null THEN a.city ELSE ma.city END)
        FROM institution i
      </when>
      <otherwise>
        COUNT(DISTINCT facet)
        FROM institution i
        INNER JOIN unnest(
        ) facet ON true
      </otherwise>
    </choose>
  </sql>

  <select id="collectionFacet" resultMap="FACET_DTO_MAP" resultType="FacetDto" parameterType="Pageable">
    <choose>
      <when test="params.facet.name.equals('CONTENT_TYPE') or params.facet.name.equals('PRESERVATION_TYPE') or params.facet.name.equals('ACCESSION_STATUS')">
        WITH vocabulary_name AS (
          SELECT
            CASE
              WHEN #{params.facet.name} = 'CONTENT_TYPE' THEN 'CollectionContentType'
              WHEN #{params.facet.name} = 'PRESERVATION_TYPE' THEN 'PreservationType'
              WHEN #{params.facet.name} = 'ACCESSION_STATUS' THEN 'AccessionStatus'
            END AS vocab_name
        ),
        facet_counts AS (
          SELECT
            vc.name AS facet,
            COUNT(DISTINCT c.key) as count
          FROM collection c
          JOIN collection_concept_links ccl ON c.key = ccl.collection_key
          JOIN grscicoll_vocab_concept vc ON ccl.concept_key = vc.concept_key
          JOIN vocabulary_name vn ON vc.vocabulary_name = vn.vocab_name
          <if test="params.descriptorSearch or params.descriptorFacet">
            INNER JOIN collection_descriptor_group cdg ON cdg.collection_key = c.key AND cdg.deleted IS NULL
            INNER JOIN collection_descriptor cd ON cd.collection_descriptor_group_key = cdg.key
          </if>
          <include refid="org.gbif.registry.persistence.mapper.collections.CollectionMapper.LIST_FILTER"/>
          <include refid="DESCRIPTORS_FILTER"/>
          AND vc.name IS NOT NULL
          GROUP BY vc.concept_key, vc.name
          <if test="params.facetMinCount != null">
            HAVING COUNT(DISTINCT c.key) >= #{params.facetMinCount}
          </if>
        )
        SELECT facet, count
        FROM facet_counts
        WHERE count > 0  -- Only return facets that have actual data
        ORDER BY count DESC, facet ASC
        <if test="params.facetPage != null">
          LIMIT #{params.facetPage.limit} OFFSET #{params.facetPage.offset}
        </if>
      </when>

      <otherwise>
        SELECT <include refid="COLLECTION_FACET_FIELDS"/> AS facet, count(DISTINCT c.key)
        FROM collection c
        <if test="params.facet.name.equals('COUNTRY') or params.facet.name.equals('CITY')">
          LEFT JOIN address a ON a.key = c.address_key
          LEFT JOIN address ma ON ma.key = c.mailing_address_key
        </if>
        <if test="params.descriptorSearch or params.descriptorFacet">
          INNER JOIN collection_descriptor_group cdg ON cdg.collection_key = c.key AND cdg.deleted IS NULL
          INNER JOIN collection_descriptor cd ON cd.collection_descriptor_group_key = cdg.key
        </if>
        <include refid="org.gbif.registry.persistence.mapper.collections.CollectionMapper.LIST_FILTER"/>
        <include refid="DESCRIPTORS_FILTER"/>
        <if test="!params.isArrayFieldFacet and params.facet != null and params.facet.name != null">
          AND <include refid="COLLECTION_FACET_FIELDS"/> IS NOT NULL
        </if>
        GROUP BY facet
        <if test="params.facetMinCount != null">
          HAVING COUNT(DISTINCT c.key) >= #{params.facetMinCount}
        </if>
        ORDER BY count(DISTINCT c.key) DESC, facet ASC
        <if test="params.facetPage != null">
          LIMIT #{params.facetPage.limit} OFFSET #{params.facetPage.offset}
        </if>
      </otherwise>
    </choose>
  </select>

  <select id="collectionFacetCardinality" resultType="Long">
    <choose>
      <when test="params.facet.name.equals('CONTENT_TYPE')">
        SELECT COUNT(DISTINCT ancestor_concept.concept_key)
        FROM
          collection c
          JOIN collection_concept_links cfl ON c.key = cfl.collection_key
          JOIN grscicoll_vocab_concept specific_concept ON cfl.concept_key = specific_concept.concept_key AND specific_concept.vocabulary_name = 'CollectionContentType'
          JOIN grscicoll_vocab_concept ancestor_concept ON specific_concept.path &lt;@ ancestor_concept.path AND ancestor_concept.vocabulary_name = 'CollectionContentType'
        <if test="params.descriptorSearch or params.descriptorFacet">
          INNER JOIN collection_descriptor_group cdg ON cdg.collection_key = c.key AND cdg.deleted IS NULL
          INNER JOIN collection_descriptor cd ON cd.collection_descriptor_group_key = cdg.key
        </if>
        <include refid="org.gbif.registry.persistence.mapper.collections.CollectionMapper.LIST_FILTER"/>
        <include refid="DESCRIPTORS_FILTER"/>
        AND ancestor_concept.name IS NOT NULL
        AND ancestor_concept.vocabulary_name = 'CollectionContentType'
      </when>
      <when test="params.facet.name.equals('PRESERVATION_TYPE')">
        SELECT COUNT(DISTINCT ancestor_concept.concept_key)
        FROM
          collection c
          JOIN collection_concept_links cfl ON c.key = cfl.collection_key
          JOIN grscicoll_vocab_concept specific_concept ON cfl.concept_key = specific_concept.concept_key AND specific_concept.vocabulary_name = 'PreservationType'
          JOIN grscicoll_vocab_concept ancestor_concept ON specific_concept.path &lt;@ ancestor_concept.path AND ancestor_concept.vocabulary_name = 'PreservationType'
        <if test="params.descriptorSearch or params.descriptorFacet">
          INNER JOIN collection_descriptor_group cdg ON cdg.collection_key = c.key AND cdg.deleted IS NULL
          INNER JOIN collection_descriptor cd ON cd.collection_descriptor_group_key = cdg.key
        </if>
        <include refid="org.gbif.registry.persistence.mapper.collections.CollectionMapper.LIST_FILTER"/>
        <include refid="DESCRIPTORS_FILTER"/>
        AND ancestor_concept.name IS NOT NULL
        AND ancestor_concept.vocabulary_name = 'PreservationType'
      </when>
      <otherwise>
        SELECT <include refid="COLLECTION_FACET_CARDINALITY_FIELDS"/>
        <if test="params.facet.name.equals('COUNTRY') or params.facet.name.equals('CITY')">
          LEFT JOIN address a ON a.key = c.address_key
          LEFT JOIN address ma ON ma.key = c.mailing_address_key
        </if>
        <include refid="org.gbif.registry.persistence.mapper.collections.CollectionMapper.LIST_FILTER"/>
        <include refid="DESCRIPTORS_FILTER"/>
      </otherwise>
    </choose>
  </select>

  <sql id="COLLECTION_FACET_FIELDS">
    <choose>
      <when test="params.facet.name.equals('COUNTRY')">
        CASE WHEN a.country is not null THEN a.country ELSE ma.country END
      </when>
      <when test="params.facet.name.equals('CITY')">
        CASE WHEN a.city is not null THEN a.city ELSE ma.city END
      </when>
      <when test="params.facet.name.equals('PRESERVATION_TYPE')">
        unnest(c.preservation_type)
      </when>
      <when test="params.facet.name.equals('CONTENT_TYPE')">
        unnest(c.content_type)
      </when>
      <when test="params.facet.name.equals('INSTITUTION_KEY')">
        c.institution_key
      </when>
      <when test="params.facet.name.equals('TYPE_STATUS')">
        unnest(cd.type_status)
      </when>
      <when test="params.facet.name.equals('RECORDED_BY')">
        unnest(cd.recorded_by)
      </when>
      <when test="params.facet.name.equals('ACCESSION_STATUS')">
        c.accession_status
      </when>
      <when test="params.facet.name.equals('TAXON_KEY')">
        unnest(cd.taxon_keys)
      </when>
      <when test="params.facet.name.equals('DESCRIPTOR_COUNTRY')">
        cd.country
      </when>
      <when test="params.facet.name.equals('KINGDOM_KEY')">
        cd.kingdom_key
      </when>
      <when test="params.facet.name.equals('PHYLUM_KEY')">
        cd.phylum_key
      </when>
      <when test="params.facet.name.equals('CLASS_KEY')">
        cd.class_key
      </when>
      <when test="params.facet.name.equals('ORDER_KEY')">
        cd.order_key
      </when>
      <when test="params.facet.name.equals('FAMILY_KEY')">
        cd.family_key
      </when>
      <when test="params.facet.name.equals('GENUS_KEY')">
        cd.genus_key
      </when>
      <when test="params.facet.name.equals('SPECIES_KEY')">
        cd.species_key
      </when>
      <when test="params.facet.name.equals('OBJECT_CLASSIFICATION')">
        cd.object_classification_name
      </when>
    </choose>
  </sql>

  <sql id="COLLECTION_FACET_CARDINALITY_FIELDS">
    <choose>
      <when test="params.facet.name.equals('COUNTRY') or params.facet.name.equals('CITY')">
        COUNT(DISTINCT CASE WHEN a.${params.facet.name} is not null THEN a.${params.facet.name} ELSE ma.${params.facet.name} END)
        FROM collection c
        <if test="params.descriptorSearch or params.descriptorFacet">
          INNER JOIN collection_descriptor_group cdg ON cdg.collection_key = c.key AND cdg.deleted IS NULL
          INNER JOIN collection_descriptor cd ON cd.collection_descriptor_group_key = cdg.key
        </if>
      </when>
      <when test="params.facet.name.equals('PRESERVATION_TYPE')
                  or params.facet.name.equals('CONTENT_TYPE')
                  or params.facet.name.equals('TYPE_STATUS')
                  or params.facet.name.equals('RECORDED_BY')
                  or params.facet.name.equals('TAXON_KEY')">
        COUNT(DISTINCT facet)
        FROM collection c
        <if test="params.descriptorSearch or params.descriptorFacet">
          INNER JOIN collection_descriptor_group cdg ON cdg.collection_key = c.key AND cdg.deleted IS NULL
          INNER JOIN collection_descriptor cd ON cd.collection_descriptor_group_key = cdg.key
        </if>
        INNER JOIN unnest(
        <choose>
          <when test="params.facet.name.equals('PRESERVATION_TYPE')">
            c.preservation_type
          </when>
          <when test="params.facet.name.equals('CONTENT_TYPE')">
            c.content_type
          </when>
          <when test="params.facet.name.equals('TYPE_STATUS')">
            cd.type_status
          </when>
          <when test="params.facet.name.equals('RECORDED_BY')">
            cd.recorded_by
          </when>
          <when test="params.facet.name.equals('TAXON_KEY')">
            cd.taxon_keys
          </when>
        </choose>
        ) facet ON true
      </when>
      <otherwise>
        COUNT(DISTINCT
        <choose>
          <when test="params.facet.name.equals('INSTITUTION_KEY')">
            c.institution_key
          </when>
          <when test="params.facet.name.equals('ACCESSION_STATUS')">
            c.accession_status
          </when>
          <when test="params.facet.name.equals('DESCRIPTOR_COUNTRY')">
            cd.country
          </when>
          <when test="params.facet.name.equals('KINGDOM_KEY')">
            cd.kingdom_key
          </when>
          <when test="params.facet.name.equals('PHYLUM_KEY')">
            cd.phylum_key
          </when>
          <when test="params.facet.name.equals('CLASS_KEY')">
            cd.class_key
          </when>
          <when test="params.facet.name.equals('ORDER_KEY')">
            cd.order_key
          </when>
          <when test="params.facet.name.equals('FAMILY_KEY')">
            cd.family_key
          </when>
          <when test="params.facet.name.equals('GENUS_KEY')">
            cd.genus_key
          </when>
          <when test="params.facet.name.equals('SPECIES_KEY')">
            cd.species_key
          </when>
          <when test="params.facet.name.equals('OBJECT_CLASSIFICATION')">
            cd.object_classification_name
          </when>
        </choose>
        ) FROM collection c
        <if test="params.descriptorSearch or params.descriptorFacet">
          INNER JOIN collection_descriptor_group cdg ON cdg.collection_key = c.key AND cdg.deleted IS NULL
          INNER JOIN collection_descriptor cd ON cd.collection_descriptor_group_key = cdg.key
        </if>
      </otherwise>
    </choose>
  </sql>

</mapper>
